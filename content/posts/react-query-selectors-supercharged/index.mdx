---
title: React Query Selectors, Supercharged
description: How to get the most out of select, sprinkled with some TypeScript tips.
date: 2025-08-04
banner: ./supercharged.jpg
tags:
  - ReactJs
  - React Query
  - TypeScript
  - Performance
---

import Comments from 'components/Comments'
import Attribution from 'components/Attribution'
import Translations from 'components/Translations'
import { RqToc } from 'components/rq-toc'
import Emph from 'components/Emph'
import Aside from 'components/Aside'

<img
  src="./supercharged.jpg"
  alt="silver coupe scale model on brown wooden table"
/>

<Attribution name="Iv√°n D√≠az" url="https://unsplash.com/@ivvndiaz" />

<RqToc id="react-query-selectors-supercharged" />

<Translations>{[]}</Translations>

Ah, [`select`](https://tanstack.com/query/latest/docs/framework/react/guides/render-optimizations#select). One of my favourite features in React Query that you'll hopefully never need. But if you need, it can be a life-saver.

<Aside title="Disclaimer" icon="shield-alert" color="var(--theme-ui-colors-warning)">

`select` is an optimization that you probably don't need when you're starting out with React Query on a small application. Especially in the contrived examples I'm using here, it might not make sense to use it. As always, there's a balance to strike between showing a more advanced concept with simple code examples that should only be a couple of lines of code long.

</Aside>

## Global State and Subscriptions

As I've described in [#18: Inside React Query](inside-react-query#querycache), React Query consists of one global state - the <Emph>QueryCache</Emph> - that holds information about all Queries. Whenever something in a Query changes, we want to inform all <Emph>QueryObservers</Emph> (the things that get created with `useQuery`) about that change.

Now ideally, we'd want to avoid that every component is subscribed to everything. A change in the `todos` Query shouldn't re-render a component that is only interested in the `profile` Query. Otherwise, we could've just used a top-level `useState` and distribute that with `React Context` throughout our application. Controlling subscriptions, and making them fine-grained, is why state management solutions exist in the first place.

## The QueryHash

As you may know, React Query has the above mentioned feature built-in. Of course, `useQuery` doesn't subscribe to the whole QueryCache. The QueryKey you pass to `useQuery` gets hashed deterministically into a <Emph>QueryHash</Emph>, and `useQuery` will only get notified about changes to that Query.

In essence, it's like we're pre-filtering down to the Query you're interested in. And mostly, that's enough. Data from one endpoint changes, your component re-renders. Data from another endpoint changes, it doesn't. So what more do we need?

## Fine-grained Subscriptions

Sometimes, endpoints return a lot of data, and we aren't interested in all of that. Especially in situations where we have fields that change often, and fields that change rarely, we might want to have subscriptions that are more fine-grained while still storing the full response in the cache. To get there, we can use `select`.

## What is `select`?

`select` is an option we can pass to `useQuery` to pick, transform, or otherwise compute a result that our component should subscribe to. It's a way to get derived state that is _very_ similar to how [deriving data with selectors](https://redux.js.org/usage/deriving-data-selectors) works in redux.

<Aside title="redux?">

Selectors aren't specific to `redux`, it's just that they work very well with the flux architecture and got popularized in react that way. But other state management solution, like [zustand](https://zustand.docs.pmnd.rs/), have them as well.

In my opinion, they are, the most explicit way to describe which data you want to get access to. React also exposes [useSyncExternalStoreWithSelector](https://github.com/facebook/react/blob/c499adf8c89bbfd884f4d3a58c4e510001383525/packages/use-sync-external-store/src/useSyncExternalStoreWithSelector.js) through their shim.

</Aside>

Let's say we fetch some product data from an API of ours:

```ts:title=productOptions
const productOptions = (id: string) => {
  return queryOptions({
    queryKey: ['product', id],
    queryFn: () => fetchProduct(id),
  })
}
```

and we want to create a component that only renders the product title

```tsx:title=ProductTitle
function ProductTitle({ id }: Props) {
  const productQuery = useSuspenseQuery(productOptions(id))

  return <h1>{productQuery.data.title}</h1>
}
```

That will certainly work, and is likely fine for most situations. However, the endpoint could also return information that might change a lot more often than the title, like the number of purchases or comments.

Of course, an occasional re-render of this simple component just because something unrelated changes isn't the end of the world, but let's assume we really want to optimize this.

That's where `select` can help: Instead of subscribing our component to all product data, we're gonna pick the field (or fields) we're interested in:

```tsx:title=select-title {4}
function ProductTitle({ id }: Props) {
  const productTitleQuery = useSuspenseQuery({
    ...productOptions(id),
    select: (data) => data.title,
  })

  return <h1>{productTitleQuery.data}</h1>
}
```

A component that uses `select` will only be subscribed to the result of the `select` function, so it will only re-render if that result changes. In this example, since the title probably doesn't change often, the component will rarely need to re-render, even if other properties of the product data change frequently.

Even better - we can also "pick" multiple properties if we want to, and we don't have to worry about referential stability, because React Query uses [structural sharing](react-query-render-optimizations#structural-sharing) on the `select` result. This is different than some other libraries, like `zustand`, where [atomic selectors](working-with-zustand#prefer-atomic-selectors) are preferred.

In essence, this means code like this will also work as you'd expect:

```tsx:title=pick-multiple-values {4-7}
function Product({ id }: Props) {
  const productQuery = useSuspenseQuery({
    ...productOptions(id),
    select: (data) => ({
      title: data.title,
      description: data.description,
    }),
  })

  return (
    <main>
      <h1>{productQuery.data.title}</h1>
      <p>{productQuery.data.description}</p>
    </main>
  )
}
```

If either `title` or `description` changes, we get a re-render, otherwise not. That's pretty cool.üòé

## Typing Select Abstractions

You might not have noticed it in the examples above, but they are all valid TypeScript code. In fact, they are not only valid, but also type-safe and inferred. That means the `data` field on the object you get back from `useQuery` will be typed to whatever `select` returns.

However, this only works if you let type inference do it's magic ü™Ñ, which means we don't want to manually "provide" generic type parameters to `useQuery`. Please read [#6: React Query and TypeScript](react-query-and-type-script#infer-all-the-things) for more information on that if you haven't done so already.

This is relatively easy to adhere to, but brings one question: How can I write a reusable abstraction in TypeScript that includes `select`? What type sorcery is needed to e.g. make `productOptions` that get `select` as an argument?

```ts:title=how-do-I-type-select? {5-6}
const productOptions = (id:string, select) => {
  return queryOptions({
    queryKey: ['product', id],
    queryFn: () => fetchProduct(id),
    // ‚¨áÔ∏è how do I type select ?
    select,
  })
}
```

My usual answer is - don't do it! We've built [the Query Options API](the-query-options-api) specifically to make it easier to abstract shared options away, while at the same time allowing you to specify additional options directly at the usage site. That's why all the code we've seen so far shows almost no indication that TypeScript is even used. Isn't that great?

But TkDodo, what if I _really_ want it? Okay, fine, if you must do this, it's a bit more involved, especially if you want `select` to be optional:

```ts:title=select-abstraction {3}
const productOptions = <TData = ProductData>(
  id: string,
  select?: (data: ProductData) => TData
) => {
  return queryOptions({
    queryKey: ['product', id],
    queryFn: () => fetchProduct(id),
    select,
  })
}
```

The trick here is to add a type parameter `TData` that defaults to whatever your `queryFn` returns, and then define `select` as a function from that type towards `TData`. That way, if you don't provide `select`, your `data` will be `ProductsData`, but if you do provide the transformation function, you will get back whatever this function returns. Here's a [TypeScript Playground](https://www.typescriptlang.org/play/?#code/JYWwDg9gTgLgBAbzgRwK4FMoE8DyYbAQB2AzgDRyonoDKVY6p6AihtnAL5wBmUEIcAEQABGAENS4gMYBrAPRR0YqTAC0aTFkEBuAFC6YWBnDgAFPgBNUKgCJjxcALyJdJgjAA26AFxwSMKGAiAHNXOAt0EilA-EIiX39AkN0OfQipDzFFHlQiFTiedBgpAAtzCCsVAApgCwSAoOCASl9ykGBqAB5yypg7cQA+fSlifzgwS2sYPAJRpzhOgBV+sXmeqZWBqrDa+qTgsjDqLxUAfl8qi3sxVsnba6anAbhl691Hx2eEMMUYVCgiCg2LhYqMqt8TCYNNgANLoLC+ADaAHIJhUpsiKLUALqHSFAzQAMXicCqH2e3CKpXW1VqTTxkOO6BUDI4TRSw1G8CQVwcXGcVFo9EY1FYmiqaN6MziJCqyNqqgAjJjwtcnqrxAA6dxeOBNdlyOT4kwAPVOuiAA) if you're curious.

## Supercharging `select` with Memoization

Since we're already optimizing, why not take it one step further and assume that our function we run in `select` is _really_ expensive. Like, maybe we're looping through a large product list and calculate the average rating for each product based on thousands of user reviews, filtering out invalid entries, and sorting the top-rated items ‚Äî all in one pass. We'll call it `expensiveSuperTransformation` from now on. If we write our code normally with `select`, here's what we get:

```tsx:title=expensiveSuperTransformation {4}
function ProductList({ filters }: Props) {
  const productsQuery = useSuspenseQuery({
    ...productListOptions(filters),
    select: (data) => expensiveSuperTransformation(data),
  })

  return (
    <ul>
      {productsQuery.data.map((product) => (
        <li>{product.summary}</li>
      ))}
    </ul>
  )
}
```

This should work fine, but there's one catch: Our `expensiveSuperTransformation` will now run on every render - not matter what caused it. To understand why, we have to know that React Query will re-run the `select` function in two cases:

1. When `data` changes.

   This should be obvious, because if we get new `data`, we might get a new result from our transformation, so we have to run it. This is fine.

2. When the `select` function itself changes.

   React Query tracks the referential identity of the `select` function as a additional performance measure. If it gets "the same function" passed in, it knows that it can only produce the same result, so it can skip running it again (Unless you rely on shared mutable state inside it, so just don't do that üòÖ).

Inline functions though are always newly created, on each render, so that optimization doesn't apply. This is actually a good feature, because it means we can close over additional props and don't have to worry about stale results:

```tsx:title=minRating {4}
function ProductList({ filters, minRating }: Props) {
  const productsQuery = useSuspenseQuery({
    ...productListOptions(filters),
    select: (data) => expensiveSuperTransformation(data, minRating),
  })

  return (
    <ul>
      {productsQuery.data.map((product) => (
        <li>{product.summary}</li>
      ))}
    </ul>
  )
}
```

Now, if `minRating` changes, we're quite happy that the `select` function re-runs to give us the newest computation. So how can we tell React Query that it's fine to skip the computation in the first example, but not in the second?

### Stabilizing `select`

The key is to pass a stable reference to `select`, and React has a good, built-in way to achieve that: `useCallback`.

<Aside title="The Useful useCallback">

The irony of this isn't lost on me, given that I've just written an article about [The Useless useCallback](the-useless-use-callback). But here, it's actually quite good. üòÇ

</Aside>

```tsx:title=select-useCallback {4-7}
function ProductList({ filters, minRating }: Props) {
  const productsQuery = useSuspenseQuery({
    ...productListOptions(filters),
    select: React.useCallback(
      (data) => expensiveSuperTransformation(data, minRating),
      [minRating]
    ),
  })

  return (
    <ul>
      {productsQuery.data.map((product) => (
        <li>{product.summary}</li>
      ))}
    </ul>
  )
}
```

Now, we'll get a stable reference passed to `select` unless `minRating` changes, and that's exactly what we want. And if we don't have any dependencies, we can even just move the function outside of our component to make it stable - no `useCallback` with empty dependency array necessary:

```tsx:title=stable-select {1-2}
const select = (data: Array<Product>) =>
  expensiveSuperTransformation(data)

function ProductList({ filters }: Props) {
  const productsQuery = useSuspenseQuery({
    ...productListOptions(filters),
    select,
  })

  return (
    <ul>
      {productsQuery.data.map((product) => (
        <li>{product.summary}</li>
      ))}
    </ul>
  )
}
```

## The Final Boss

This works great so far, but wait, there's more. What happens if we render the same component multiple times now. How often do you think `select` would run?

Well, it runs once per component. Specifically, once per `QueryObserver`, because that's where the result of `select` is cached. Each call to `useQuery` creates a `QueryObserver`, so it has to run `select` at least once for each of those.

That's a bummer because it means our `expensiveSuperTransformation` might still run more than once per `data`, and we _really_ don't want that. What can we do?

We add more memoization, of course!

### More Memoization

We really just want to memoize our `expensiveSuperTransformation` by its inputs, but this has to happen outside of React Query, because React Query caches this per observer. So, we can bring in a library like [fast memoize](https://www.npmjs.com/fast-memoize) that'll do just that:

```tsx:title=fast-memoize {3-5}
import memoize from 'fast-memoize'

const select = memoize((data: Array<Product>) =>
  expensiveSuperTransformation(data)
)

function ProductList({ filters }: Props) {
  const productsQuery = useSuspenseQuery({
    ...productListOptions(filters),
    select,
  })

  return (
    <ul>
      {productsQuery.data.map((product) => (
        <li>{product.summary}</li>
      ))}
    </ul>
  )
}
```

Let's say we render our `ProductList` three times now. What happens is that `select` will run all three times (once per `QueryObserver`, there's no way around that), but the `expensiveSuperTransformation` will only run once because it will hit the cache of `fast-memoize` twice, as it runs with the same `data`. And if `data` changes, same thing: three runs of `select`, but only one run of the `expensiveSuperTransformation`.

That is as optimized as we can be.

---

That's it for today. Feel free to reach out to me on [bluesky](https://bsky.app/profile/tkdodo.eu)
if you have any questions, or just leave a comment below. ‚¨áÔ∏è

<Comments />
